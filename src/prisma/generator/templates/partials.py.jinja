{% include '_header.py.jinja' %}
{% from '_utils.py.jinja' import recursive_types, query_methods with context %}
# -- template partials.py.jinja --
from pydantic import validator
from . import types, fields, enums, actions
from .bases import PrismaModelT, PrismaModel as _PrismaModel


{% for partial in partial_models %}
class {{ partial.name }}(_PrismaModel):
    {% for field in partial.fields.values() %}
    {{ field.name }}:
            {%- if field.optional -%}
                {{ ' ' }}Optional[{{ field.type }}]
            {% else -%}
                {{ ' ' }}{{ field.type }}
            {% endif %}
    {% endfor %}

    __prisma_model__: ClassVar[str] = '{{ partial.from_model }}'

    {{ query_methods(partial.from_model, false) }}

    {# TODO: this should be one validator for all bytes types #}
    {# TODO: this type check feels very hacky #}
    {% for field in partial.fields %}
    {% if field.type in ['fields.Base64', 'List[\'fields.Base64\']'] %}
    @validator('{{ field.name }}', pre=True, allow_reuse=True)
    @classmethod
    def _prisma_{{ field.name }}_bytes_validator(cls, value: Any) -> Union[fields.Base64, List[fields.Base64]]:
        return fields.Base64._internal_from_prisma(value)
    {% endif %}
    {% endfor %}


{% endfor %}

# users can modify relational types which are then namespaced to partials.
# so we have to import ourselves in order to resolve forward references
from . import partials

{% for partial in partial_models %}
{{ partial.name }}.update_forward_refs()
{% endfor %}

# fmt: on

