{% include '_header.py.jinja' %}
{% from '_utils.py.jinja' import recursive_types, active_provider with context %}
# -- template fields.py.jinja --
import base64
from pydantic import Json as _PydanticJson

from . import errors


__all__ = (
    'Json',
    'JsonPath',
    'Base64',
)


_JsonKeys = Union[
    None,
    bool,
    float,
    int,
    str,
]

# Base64 data should only be valid ascii, we limit our encoding to ascii so that
# any erroneous data is caught as early on as possible.
BASE64_ENCODING = 'ascii'


if TYPE_CHECKING:
    # we inherit from _PydanticJson at runtime but do not when type checking
    # so that a distinction can be made between Json and str types
    # TODO: show example
    class Json:
        data: 'Serializable'

        def __init__(self, data: 'Serializable') -> None:
            ...

        @classmethod
        def keys(cls, **data: 'Serializable') -> 'Json':
            ...

        # Fields that are of the `Json` type are automatically
        # de-serialized from json to the corresponding python type
        # when the model is created, e.g.
        #
        # User(json_obj='{"foo": null}') -> User(json_obj={'foo': None})
        #
        # As we don't know what the type will actually be at runtime
        # we add methods here for convenience so that naive access
        # to the field is still allowed, e.g.
        #
        # user.json_obj['foo']
        # user.json_obj[1]
        # user.json_obj[1:5]
        #
        # It should be noted that users will still have
        # to validate / cast fields to the type they are expecting
        # for any strict type binding or nested index calls to work, e.g.
        #
        # isinstance(user.json_obj, dict)
        # cast(Dict[str, Any], user.json_obj)
        # prisma.validate(ExpectedType, user.json_obj)
        @overload  # type: ignore
        def __getitem__(self, i: slice) -> List['Serializable']:
            ...

        @overload
        def __getitem__(self, i: '_JsonKeys') -> 'Serializable':  # pyright: reportIncompatibleMethodOverride=false
            ...

        def __getitem__(self, i: Union['_JsonKeys', slice]) -> 'Serializable':
            ...
else:
    # inherit from _PydanticJson so that pydantic will automatically
    # transform the json string into python objects.
    class Json(_PydanticJson):
        data: 'Serializable'

        def __init__(self, data: 'Serializable') -> None:
            self.data = data
            super().__init__()

        @classmethod
        def keys(cls, **data: 'Serializable') -> 'Json':
            return cls(data)


class JsonPath:

    path: Union[str, List[str]]

    # TODO: static type error if not supported
    def __init__(self, *args: str) -> None:
        {% if active_provider == 'postgresql' %}
        self.path = self._postgres_path(*args)
        {% elif active_provider == 'mysql' %}
        self.path = self._mysql_path(*args)
        {% else %}
        raise errors.UnsupportedDatabaseError('Json filtering', '{{ active_provider }}')
        {% endif %}

    @staticmethod
    def _mysql_path(*args: str) -> str:
        return '.'.join(['$', *args])

    @staticmethod
    def _postgres_path(*args: str) -> List[str]:
        return [item for item in args]


class Base64:
    def __init__(self, raw: bytes) -> None:
        self._raw = raw

    @classmethod
    def encode(cls, value: bytes) -> 'Base64':
        """Encode bytes into valid Base64"""
        return cls(base64.b64encode(value))

    def decode(self, encoding: str = BASE64_ENCODING) -> bytes:
        """Decode from Base64 to the original bytes object"""
        return base64.b64decode(self._raw)

    # NOTE: we explicitly use a different encoding here as we are decoding
    # to the original data provided by the user, this data does not have
    # the limitation of being ascii only that the raw Base64 data does
    def decode_str(self, encoding: str = 'utf-8') -> str:
        """Decode from Base64 to the original string

        This decodes using the `utf-8` encoding by default,
        you can customise the encoding like so:

        ```py
        value = b64.decode_str('ascii')
        ```
        """
        return self.decode().decode(encoding)

    def __str__(self) -> str:
        return self._raw.decode(BASE64_ENCODING)

    def __repr__(self) -> str:
        return f'{self.__class__.__name__}({self._raw})'  # type: ignore[str-bytes-safe]

    def __eq__(self, other: Any) -> bool:
        if isinstance(other, Base64):
            return self._raw == other._raw

        return False

    @classmethod
    def _internal_from_prisma(cls, value: Union[str, List[str]]) -> Union['Base64', List['Base64']]:
        if isinstance(value, list):
            return [cls(bytes(item, BASE64_ENCODING)) for item in value]

        return cls(bytes(value, BASE64_ENCODING))


from .types import Serializable
