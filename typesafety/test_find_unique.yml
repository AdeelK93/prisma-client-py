- case: find_unique_where_incorrect_inputs
  main: |
    from prisma import Client

    async def main() -> None:
      client = Client()
      await client.post.find_unique()  # E: Missing positional argument "where" in call to "find_unique" of "PostActions"  [call-arg]

      await client.post.find_unique({'published': False})  # E: Extra key 'published' for TypedDict "PostWhereUniqueInput"  [typeddict-item]
      await client.post.find_unique({'title': 'Hello, world'})  # E: Extra key 'title' for TypedDict "PostWhereUniqueInput"  [typeddict-item]

      await client.post.find_unique({'id': 2})  # E: Incompatible types (expression has type "int", TypedDict item "id" has type "str")  [typeddict-item]

- case: find_unique_output
  main: |
    from prisma import Client

    async def main() -> None:
      client = Client()
      post = await client.post.find_unique({'id': 'dbkh232'})
      reveal_type(post)  # N: Revealed type is 'Union[prisma.models.Post, None]'

      if post is not None:
        reveal_type(post.id)  # N: Revealed type is 'builtins.str'
        reveal_type(post.title)  # N: Revealed type is 'builtins.str'
        reveal_type(post.published)  # N: Revealed type is 'builtins.bool'
        reveal_type(post.title.lower())  # N: Revealed type is 'builtins.str'
        oops = post.oops  # E: "Post" has no attribute "oops"  [attr-defined]

- case: find_unique_dynamic_where
  main: |
    from prisma import Client
    from prisma.types import PostWhereUniqueInput

    async def main() -> None:
      client = Client()

      data: PostWhereUniqueInput = {}

      if True:
        data['id'] = '983293asdsad'
        data['invalid'] = True  # E: TypedDict "PostWhereUniqueInput" has no key 'invalid'  [misc]

      post = await client.post.find_unique(data)
      reveal_type(post)  # N: Revealed type is 'Union[prisma.models.Post, None]'
