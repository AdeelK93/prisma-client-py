- case: find_unique_where_incorrect_inputs
  main: |
    from prisma import Client

    async def main() -> None:
      client = Client()
      await client.post.find_unique()  # E: Too few arguments for "find_unique" of "PostActions"

      await client.post.find_unique({'published': False})  # E: Extra key 'published' for TypedDict "PostWhereUniqueInput"
      await client.post.find_unique({'title': 'Hello, world'})  # E: Extra key 'title' for TypedDict "PostWhereUniqueInput"

      await client.post.find_unique({'id': 2})  # E: Incompatible types (expression has type "int", TypedDict item "id" has type "str")

- case: find_unique_output
  main: |
    from prisma import Client

    async def main() -> None:
      client = Client()
      post = await client.post.find_unique({'id': 'dbkh232'})
      reveal_type(post)  # N: Revealed type is 'prisma.client.Post*'
      reveal_type(post.id)  # N: Revealed type is 'builtins.str'
      reveal_type(post.title)  # N: Revealed type is 'builtins.str'
      reveal_type(post.published)  # N: Revealed type is 'builtins.bool'
      reveal_type(post.title.lower())  # N: Revealed type is 'builtins.str'
      oops = post.oops  # E: "Post" has no attribute "oops"

- case: find_unique_dynamic_where
  main: |
    from prisma import Client
    from prisma.types import PostWhereUniqueInput

    async def main() -> None:
      client = Client()

      data: PostWhereUniqueInput = {}

      if True:
        data['id'] = '983293asdsad'
        data['invalid'] = True  # E: TypedDict "PostWhereUniqueInput" has no key 'invalid'

      post = await client.post.find_unique(data)
      reveal_type(post)  # N: Revealed type is 'prisma.client.Post*'
