{% include '_header.py.jinja' %}
# -- template types.py.jinja --
from enum import Enum

{% set depth = generator.config.recursive_type_depth %}

# TODO: cleanup whitespace control
# TODO: add an argument to signify that the last iteration should be skipped
{% macro recursive() %}
    {%+ for i in range(depth) -%}
        {% if i == 0 %}
            {% set name = '' %}
        {% else %}
            {% set name = 'Recursive%s' % i %}
        {% endif %}

        {% if i == depth - 1 %}
            {% set next = '' %}
        {% else %}
            {% set next = 'Recursive%s' % (i + 1) %}

        {% endif %}

{{ caller(name, next) }}
    {%- endfor %}
{% endmacro %}


SortOrder = Literal['asc', 'desc']


{% call(current, next) recursive() %}
class StringFilter{{ current }}(TypedDict, total=False):
    equals: str
    not_in: List[str]
    lt: str
    lte: str
    gt: str
    gte: str
    contains: str
    startswith: str
    endswith: str
    IN: List[str]
    {%+ if next != '' -%}
        NOT: Union[str, 'StringFilter{{ next }}']
    {% endif %}
{% endcall %}

{% call(current, next) recursive() %}
class DatetimeFilter{{ current }}(TypedDict, total=False):
    equals: datetime.datetime
    not_in: List[datetime.datetime]
    lt: datetime.datetime
    lte: datetime.datetime
    gt: datetime.datetime
    gte: datetime.datetime
    IN: List[datetime.datetime]
    {%+ if next != '' -%}
        NOT: 'DatetimeFilter{{ next }}'
    {% endif %}
{% endcall %}


{% call(current, next) recursive() %}
class BooleanFilter{{ current }}(TypedDict, total=False):
    equals: bool
    {%+ if next != '' -%}
        NOT: Union[bool, 'BooleanFilter{{ next }}']
    {% endif %}
{% endcall %}


{% call(current, next) recursive() %}
class IntFilter{{ current }}(TypedDict, total=False):
    equals: int
    IN: List[int]
    not_in: List[int]
    lt: int
    lte: int
    gt: int
    gte: int
    {%+ if next != '' -%}
        NOT: Union[int, 'IntFilter{{ next }}']
    {% endif %}
{% endcall %}


{% call(current, next) recursive() %}
class FloatFilter{{ current }}(TypedDict, total=False):
    equals: float
    IN: List[float]
    not_in: List[float]
    lt: float
    lte: float
    gt: float
    gte: float
    {%+ if next != '' -%}
        NOT: Union[float, 'FloatFilter{{ next }}']
    {% endif %}
{% endcall %}


{% for enum in dmmf.datamodel.enums %}
class {{ enum.name }}Enum(str, Enum):
    {% for value in enum.values %}
    {{ value.name }} = '{{ value.name }}'
    {% endfor %}
{% endfor %}

{% for model in dmmf.datamodel.models %}
# {{ model.name }} types

class {{ model.name }}OptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the {{ model.name }} create method"""
    {% for field in model.all_fields %}
        {%- if not field.required_on_create and not field.is_read_only -%}
            {{'    '}}{{ field.python_case }}: Optional[{{ field.create_input_type }}]
        {% endif %}
    {% endfor %}


class {{ model.name }}CreateInput({{ model.name }}OptionalCreateInput):
    """Required arguments to the {{ model.name }} create method"""
    {% for field in model.all_fields %}
        {%- if field.required_on_create and not field.is_read_only -%}
            {{'    '}}{{ field.python_case }}: {{ field.create_input_type }}
        {% endif %}
    {% endfor %}


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class {{ model.name }}OptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the {{ model.name }} create method, without relations"""
    {% for field in model.all_fields %}
        {%- if not field.required_on_create and not field.is_read_only and not field.relation_name -%}
            {{'    '}}{{ field.python_case }}: Optional[{{ field.python_type }}]
        {% endif %}
    {% endfor %}


class {{ model.name }}CreateWithoutRelationsInput({{ model.name }}OptionalCreateWithoutRelationsInput):
    """Required arguments to the {{ model.name }} create method, without relations"""
    {% for field in model.all_fields %}
        {%- if field.required_on_create and not field.is_read_only and not field.relation_name -%}
            {{'    '}}{{ field.python_case }}: {{ field.python_type }}
        {% endif %}
    {% endfor %}


class {{ model.name }}CreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: Optional['{{ model.name }}CreateWithoutRelationsInput']
    connect: Optional['{{ model.name }}WhereUniqueInput']


class {{ model.name }}CreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Optional[Union['{{ model.name }}CreateWithoutRelationsInput', List['{{ model.name }}CreateWithoutRelationsInput']]]
    connect: Optional[Union['{{ model.name }}WhereUniqueInput', List['{{ model.name }}WhereUniqueInput']]]


# TODO: what if a relational field is unique?
class {{ model.name }}WhereUniqueInput(TypedDict, total=False):
    """Unique {{ model.name }} arguments for searching"""
    {% for field in model.all_fields %}
        {%- if field.is_unique or field.is_id -%}
            {{'    '}}{{ field.python_case }}: {{ field.python_type }}
        {% endif %}
    {% endfor %}


class {{ model.name }}UpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    {% for field in model.all_fields %}
        {%- if not field.is_unique and not field.is_id and not field.is_read_only -%}
            {{'    '}}{{ field.python_case }}: Optional[{{ field.get_update_input_type(model.name) }}]
        {% endif %}
    {% endfor %}


{% for field in model.atomic_fields %}
class {{ model.name }}Update{{ field.name }}Input(TypedDict, total=False):
    set: {{ field.atomic_type }}
    {% if field.type != 'Boolean' %}
    increment: {{ field.atomic_type }}
    decrement: {{ field.atomic_type }}
    multiply: {{ field.atomic_type }}
    divide: {{ field.atomic_type }}
    {% endif %}
{% endfor %}


class {{ model.name }}UpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['{{ model.name }}CreateWithoutRelationsInput']
    connect: List['{{ model.name }}WhereUniqueInput']
    set: List['{{ model.name }}WhereUniqueInput']
    disconnect: List['{{ model.name }}WhereUniqueInput']
    delete: List['{{ model.name }}WhereUniqueInput']

    # TODO
    # update: List['{{ model.name }}UpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['{{ model.name }}UpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['{{ model.name }}ScalarWhereInput']
    # upsert: List['{{ model.name }}UpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['{{ model.name }}CreateOrConnectWithoutRelationsInput']


class {{ model.name }}UpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: '{{ model.name }}CreateWithoutRelationsInput'
    connect: '{{ model.name }}WhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: '{{ model.name }}UpdateInput'
    # upsert: '{{ model.name }}UpsertWithoutRelationsInput'
    # connectOrCreate: '{{ model.name }}CreateOrConnectWithoutRelationsInput'


class {{ model.name }}UpsertInput(TypedDict, total=False):
    create: '{{ model.name }}CreateInput'
    update: '{{ model.name }}UpdateInput'


class {{ model.name }}OrderByInput(TypedDict, total=False):
    {% for field in model.scalar_fields %}
    {{ field.name }}: Optional['SortOrder']
    {% endfor %}


# recursive {{ model.name }} types


class {{ model.name }}Include(TypedDict, total=False):
    """{{ model.name }} relational arguments"""
    {% for field in model.relational_fields -%}
        {{'    '}}{{ field.python_case }}: Union[bool, '{{ field.relational_args_type }}From{{ model.name }}']
    {% endfor %}


{% for related in dmmf.datamodel.models %}
{% call(current, next) recursive() %}
class {{ related.name }}IncludeFrom{{ model.name }}{{ current }}(TypedDict, total=False):
    """Relational arguments for {{model.name }}"""
    {% if next != '' -%}
        {% for field in related.relational_fields -%}
            {{'    '}}{{ field.python_case }}: Union[bool, '{{ field.relational_args_type }}From{{ model.name + next }}']
        {% endfor %}
    {% endif %}
{% endcall %}

{% call(current, next) recursive() %}
class {{ related.name }}ArgsFrom{{ model.name }}{{ current }}(TypedDict, total=False):
    """Arguments for {{model.name }}"""
    {%+ if next != '' -%}
        include: '{{ related.name }}IncludeFrom{{ related.name + next}}'
    {% endif %}
{% endcall %}

{% call(current, next) recursive() %}
class FindMany{{ related.name }}ArgsFrom{{ model.name}}{{ current }}(TypedDict, total=False):
    """Arguments for {{model.name }}"""
    take: int
    skip: int
    order_by: Union['{{ model.name }}OrderByInput', List['{{ model.name }}OrderByInput']]
    where: '{{ related.name }}WhereInput'
    cursor: '{{ related.name }}WhereUniqueInput'
    {%+ if next != '' -%}
        include: '{{ related.name }}IncludeFrom{{ related.name + next}}'
    {% endif %}
{% endcall %}

{% endfor %}


# TODO: support relationships here
{% call(current, next) recursive() %}
class {{ model.name }}WhereInput{{ current }}(TypedDict, total=False):
    """{{ model.name }} arguments for searching"""
    {% for field in model.all_fields %}
        {%- if not field.relation_name -%}
            {{'    '}}{{ field.python_case }}: {{ field.where_input_type }}
        {% endif %}
    {% endfor %}

    {% if next != '' %}
    AND: List['{{ model.name }}WhereInput{{ next }}']
    OR: List['{{ model.name }}WhereInput{{ next }}']
    NOT: List['{{ model.name }}WhereInput{{ next }}']
    {% endif %}
{% endcall %}

{% endfor %}


# we have to import ourselves as enum types are namespaced to types
# e.g. types.RoleEnum
from prisma import types, models
